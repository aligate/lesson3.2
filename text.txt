1. Распишите своё понимание полиморфизма и наследования своими словами.

Полиформизм можно объяснить на следующем примере. Допустим два иностранных студента учатся в поварской школе в России, научились готовить борщ. По окончании учебы разъезжаются по домам, один в Азию, другой в Европу. Приехав на родину, готовят борщ своим землякам по рецепту как их учили. Однако не всем нравится борщ как его готовят в России, и люди дают советы, что можно изменить в рецепте, в соответствии с их вкусами. Постепенно эти повара отходят от первоначального рецепта, добавляя в него что то новое, например другой вид мяса, приправы или овощи из их региона. Так что получилось три варианта борща: русский, азиатский и еврепейский. Все три будут называться борщом, основа у них одна, но у каждого будет свой национальный колорит. 

Наследование и полиморфизм действуют в одной связке. Наследование предполагает,что дочерний класс перенимает все свойства и методы родителя, которые не являются приватными, и может добавлять к ним что то своё. В этом проявляется полиморфизм. То же самое происходит в реальном мире. Дети не на 100 % похожи на своих родителей, хотя многое от них перенимают, да и врядь ли в мире есть существа, которые были бы на 100% похожи, даже в пределах одного вида. То что есть общего у родительских и дочерних классов, помогает их классифицировать и объединять в одну структуру. А то, что их отличает, помогает расширять эту структуру. 

2. Своими словами распишите отличие интерфейсов и абстрактных классов. В чем отличие? Когда лучше использовать одно, когда другое.

Отличие абстрактных классов от интерфейсов в том, что абстрактный класс - это как правило вершина пирамиды классов, от которых создаются объекты. Как и обычные классы абстрактный может описывать в себе полноценные свойства и методы, и роль его в том, чтобы собрать в себе те свойства и методы, которыми будут пользоваться все дочерние классы, их не дублируя. Дочерний класс может напрямую наследовать только один абстрактный. Между абстрактным и дочерним классом может быть целая цепочка промежуточных классов. Абстрактный класс не для того, чтобы создавать объекты, он объединяет нисходящие классы в одну систему. В отличие от него интерфейс может быть реализовать любым дочерним классом независимо от иерархии наследования. Например, определенным  дочерним классам нужен метод, которого нет в абстрактном, да и смысла нет его туда помещать, поскольку метод нужен только определенным  классам. В таком случае эти определенные классы реализуют интерфейс. Интерфейс как бы выделяет эти дочерние классы в отдельный контекст, в подгруппу дочерних классов в той же системе, на вершине которой стоит абстрактный класс. И классы, имплементирующие интерфейс, обязаны теперь реализовать методы, которых нет в абстрактном классе, но есть в интерфейсе. Так что абстрактный класс и интерфейс не заменяют друг друга, а могут дополнять друг друга. И в общем и целом интерфейсы нужны тогда, когда на определенном участке иерархии наследования нужно добавить функционал, который не описан в абстрактном классе.   